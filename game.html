<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ç½‘é¡µç‰ˆæ°´æœåˆ‡åˆ‡ä¹</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #8b5a2b;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            /* ç®€åŒ–èƒŒæ™¯ï¼šåªä¿ç•™åŸºç¡€æœ¨çº¹å’Œæš—è§’ï¼Œæ’é™¤å¤æ‚æ¸å˜å¯¼è‡´çš„æ¸²æŸ“å´©æºƒ */
            background-image: 
                radial-gradient(circle, rgba(0,0,0,0.1), rgba(0,0,0,0.6)),
                linear-gradient(to bottom, #a0522d, #5c3317);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* è°ƒè¯•æ—¥å¿—çª—å£ (é»˜è®¤éšè—ï¼Œå‡ºé”™æ—¶æ˜¾ç¤º) */
        #debug-log {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: #ff4757;
            font-family: monospace;
            padding: 10px;
            z-index: 9999;
            pointer-events: none;
            white-space: pre-wrap;
            font-size: 14px;
        }

        /* UI è¦†ç›–å±‚ */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 5;
        }

        .score-board {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            display: flex;
            gap: 20px;
            margin-top: 40px; /* å¢åŠ é¡¶éƒ¨é—´è·é¿å…é®æŒ¡ */
        }

        .lives {
            color: #ff4757;
            font-size: 24px;
        }

        /* èœå•å±å¹• */
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            pointer-events: auto;
        }

        h1 {
            font-size: 40px;
            margin-bottom: 10px;
            color: #ffd700;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        p {
            font-size: 16px;
            color: #ddd;
            margin-bottom: 30px;
            text-align: center;
            padding: 0 20px;
        }

        button {
            padding: 15px 40px;
            font-size: 22px;
            background: linear-gradient(45deg, #ff6b6b, #ff4757);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4);
            touch-action: manipulation;
        }

        button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        #final-score {
            font-size: 60px;
            font-weight: bold;
            color: #2ed573;
            margin: 20px 0;
        }

        /* æ°´å°æ ·å¼ */
        .watermark {
            position: absolute;
            top: 15px; 
            left: 0;
            width: 100%; 
            text-align: center; 
            color: rgba(255, 255, 255, 0.3);
            font-size: 16px;
            font-weight: bold;
            pointer-events: none; 
            z-index: 100;
            user-select: none;
            font-family: "Microsoft YaHei", sans-serif;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            letter-spacing: 2px;
        }
    </style>
</head>
<body>

<div id="debug-log"></div>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- æ°´å° -->
    <div class="watermark">æ‰¿é¾™æ¸¸æˆåˆ¶ä½œï¼Œç›—ç‰ˆå¿…ç©¶</div>

    <!-- æ¸¸æˆ UI -->
    <div class="ui-layer">
        <div class="score-board">
            <span id="score-display">åˆ†æ•°: 0</span>
            <span id="best-score-display">æœ€é«˜: 0</span>
        </div>
        <div class="lives" id="lives-display">â¤ï¸â¤ï¸â¤ï¸</div>
    </div>

    <!-- å¼€å§‹ç•Œé¢ -->
    <div id="start-screen">
        <h1>ğŸ‰ æ°´æœåˆ‡åˆ‡ä¹ ğŸŒ</h1>
        <p>æ‰‹æŒ‡åˆ’è¿‡å±å¹•åˆ‡å¼€æ°´æœ<br>ä¸è¦åˆ‡åˆ°é»‘è‰²ç‚¸å¼¹ï¼</p>
        <button id="start-btn">å¼€å§‹æ¸¸æˆ</button>
    </div>

    <!-- ç»“æŸç•Œé¢ -->
    <div id="game-over-screen" class="hidden">
        <h1>æ¸¸æˆç»“æŸ</h1>
        <p>æœ¬å±€å¾—åˆ†</p>
        <div id="final-score">0</div>
        <button id="restart-btn">å†ç©ä¸€æ¬¡</button>
    </div>
</div>

<script>
    // --- å…¨å±€é”™è¯¯æ•è· (å¦‚æœåœ¨æ‰‹æœºä¸ŠæŠ¥é”™ï¼Œä¼šæ˜¾ç¤ºåœ¨å±å¹•é¡¶éƒ¨) ---
    window.onerror = function(msg, url, line) {
        const log = document.getElementById('debug-log');
        if(log) {
            log.style.display = 'block';
            log.innerHTML += "é”™è¯¯: " + msg + " (è¡Œå·: " + line + ")<br>";
        }
        return false;
    };
    
    // --- å…¨å±€å˜é‡å£°æ˜ ---
    let canvas, ctx, scoreEl, bestScoreEl, livesEl, startScreen, gameOverScreen, finalScoreEl, startBtn, restartBtn;

    // æ¸¸æˆçŠ¶æ€
    let gameState = 'MENU';
    let score = 0;
    let lives = 3;
    let gameTime = 0;
    
    // å®ä½“æ•°ç»„
    let fruits = [];
    let particles = [];
    let trailPoints = [];

    // æ°´æœå®šä¹‰
    const FRUIT_TYPES = [
        { emoji: 'ğŸ‰', color: '#ff6b6b', points: 10, radius: 50 },
        { emoji: 'ğŸŒ', color: '#ffeaa7', points: 15, radius: 45 },
        { emoji: 'ğŸ', color: '#ff4757', points: 10, radius: 45 },
        { emoji: 'ğŸ', color: '#f9ca24', points: 20, radius: 50 },
        { emoji: 'ğŸŠ', color: '#ff9f43', points: 10, radius: 45 },
        { emoji: 'ğŸ¥¥', color: '#dfe4ea', points: 25, radius: 48 },
        { emoji: 'ğŸ¥', color: '#badc58', points: 15, radius: 45 }
    ];

    const BOMB_TYPE = { emoji: 'ğŸ’£', color: '#2f3542', radius: 50 };

    // è¾“å…¥è¿½è¸ª
    const input = { x: 0, y: 0, isDown: false };

    // --- éŸ³é¢‘ç³»ç»Ÿ (ä¿®å¤ç‰ˆ) ---
    let audioCtx = null;
    let audioEnabled = true;

    function initAudio() {
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) {
                audioEnabled = false;
                return;
            }
            if (!audioCtx) {
                audioCtx = new AudioContext();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().catch(e => console.log("Audio resume failed"));
            }
        } catch (e) {
            console.log("éŸ³é¢‘åˆå§‹åŒ–å¼‚å¸¸ï¼Œå·²é™éŸ³");
            audioEnabled = false;
        }
    }

    function playSound(type) {
        if (!audioEnabled || !audioCtx) return;
        // åŒé‡æ£€æŸ¥ä¸Šä¸‹æ–‡çŠ¶æ€
        if (audioCtx.state === 'suspended') {
             audioCtx.resume().catch(()=>{});
             return; 
        }

        try {
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            if (type === 'slice') {
                const bufferSize = audioCtx.sampleRate * 0.1;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(1000, t);
                
                noise.connect(filter);
                filter.connect(gain);
                
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                
                gain.connect(audioCtx.destination);
                noise.start();
            } else if (type === 'throw') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.exponentialRampToValueAtTime(600, t + 0.1);
                
                gain.gain.setValueAtTime(0.05, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.15);
                
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(t + 0.2);
            }
        } catch (e) {
            // å¿½ç•¥æ’­æ”¾é”™è¯¯
        }
    }

    // --- åˆå§‹åŒ–ä¸äº‹ä»¶ç›‘å¬ ---
    function resize() {
        if (!canvas) return; // å®‰å…¨æ£€æŸ¥
        canvas.width = window.innerWidth || document.documentElement.clientWidth;
        canvas.height = window.innerHeight || document.documentElement.clientHeight;
    }
    
    function getEventPos(e) {
        if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
    }

    function handleInputStart(e) {
        if (e.type === 'mousedown' && e.button !== 0) return;
        if (e.type === 'touchstart') e.preventDefault();
        
        input.isDown = true;
        const pos = getEventPos(e);
        input.x = pos.x;
        input.y = pos.y;
        trailPoints = [];
    }

    function handleInputMove(e) {
        if (!input.isDown) return;
        e.preventDefault(); 
        const pos = getEventPos(e);
        input.x = pos.x;
        input.y = pos.y;
        addTrailPoint(input.x, input.y);
        checkCollisions(input.x, input.y);
    }

    function handleInputEnd(e) {
        input.isDown = false;
        trailPoints = [];
    }

    function bindEvents() {
        window.addEventListener('resize', resize);
        window.addEventListener('orientationchange', () => setTimeout(resize, 200)); 

        // é¼ æ ‡äº‹ä»¶
        canvas.addEventListener('mousedown', handleInputStart);
        canvas.addEventListener('mousemove', handleInputMove);
        window.addEventListener('mouseup', handleInputEnd);

        // è§¦æ‘¸äº‹ä»¶
        canvas.addEventListener('touchstart', handleInputStart, {passive: false});
        canvas.addEventListener('touchmove', handleInputMove, {passive: false});
        window.addEventListener('touchend', handleInputEnd);

        startBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            initAudio(); 
            startGame();
        });
        
        startBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            e.preventDefault();
            initAudio(); 
            startGame();
        }, {passive: false});

        restartBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            e.preventDefault();
            startGame();
        }, {passive: false});
    }

    function init() {
        // ç¡®ä¿æ‰€æœ‰å…ƒç´ éƒ½å·²åŠ è½½
        canvas = document.getElementById('gameCanvas');
        if (!canvas) {
            // å¦‚æœ Canvas æ²¡æ‰¾åˆ°ï¼Œæ˜¾ç¤ºè‡´å‘½é”™è¯¯ä¿¡æ¯
            const log = document.getElementById('debug-log');
            if(log) {
                 log.style.display = 'block';
                 log.innerHTML = "è‡´å‘½é”™è¯¯: æ— æ³•æ‰¾åˆ° Canvas å…ƒç´ ï¼Œå¯èƒ½æ˜¯ HTML ç»“æ„åŠ è½½å¤±è´¥ã€‚<br>";
            }
            return; 
        }

        ctx = canvas.getContext('2d'); 
        scoreEl = document.getElementById('score-display');
        bestScoreEl = document.getElementById('best-score-display');
        livesEl = document.getElementById('lives-display');
        startScreen = document.getElementById('start-screen');
        gameOverScreen = document.getElementById('game-over-screen');
        finalScoreEl = document.getElementById('final-score');
        startBtn = document.getElementById('start-btn');
        restartBtn = document.getElementById('restart-btn');

        resize();
        bindEvents();

        // --- ä¿®å¤ LocalStorage å´©æºƒé—®é¢˜ ---
        let bestScore = 0;
        try {
            bestScore = localStorage.getItem('fruitNinjaBestScore') || 0;
        } catch (e) {
            // LocalStorage ä¸å¯ç”¨
        }
        bestScoreEl.innerText = `æœ€é«˜: ${bestScore}`;

    }

    window.addEventListener('load', init); // åœ¨æ•´ä¸ªé¡µé¢åŠ è½½å®Œæˆåæ‰§è¡Œ init

    // --- æ¸¸æˆç±» ---

    class Fruit {
        constructor() {
            this.reset();
        }

        reset() {
            const isBomb = Math.random() < Math.min(0.1 + (gameTime * 0.0001), 0.3);
            if (isBomb) {
                this.type = BOMB_TYPE;
                this.isBomb = true;
            } else {
                this.type = FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
                this.isBomb = false;
            }

            const margin = 50;
            this.x = Math.random() * (canvas.width - margin * 2) + margin;
            this.y = canvas.height + 60;
            
            const direction = this.x > canvas.width / 2 ? -1 : 1;
            this.vx = (Math.random() * 2 + 1) * direction; 
            
            this.gravity = 0.12; 
            const targetHeight = canvas.height * (0.5 + Math.random() * 0.3);
            this.vy = -Math.sqrt(2 * this.gravity * targetHeight);
            
            this.rotation = 0;
            this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            this.active = true;
            this.sliced = false;

            if (gameState === 'PLAYING') playSound('throw');
        }

        update() {
            if (!this.active) return;
            this.x += this.vx;
            this.y += this.vy;
            this.vy += this.gravity;
            this.rotation += this.rotationSpeed;

            if (this.x < this.type.radius) {
                this.x = this.type.radius;
                this.vx *= -0.5;
            } else if (this.x > canvas.width - this.type.radius) {
                this.x = canvas.width - this.type.radius;
                this.vx *= -0.5;
            }

            if (this.y > canvas.height + 70) {
                this.active = false;
                if (!this.isBomb && !this.sliced && gameState === 'PLAYING') {
                    loseLife();
                }
            }
        }

        draw() {
            if (!this.active || this.sliced) return;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            // å…¼å®¹æ€§å­—ä½“è®¾ç½®
            ctx.font = "80px 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', Arial, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(this.type.emoji, 0, 10); 
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color, isText = false, text = '') {
            this.x = x;
            this.y = y;
            this.color = color;
            this.isText = isText;
            this.text = text;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 4 + 2;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 1.0;
            this.decay = Math.random() * 0.02 + 0.015;
            this.gravity = 0.15;
            this.size = Math.random() * 5 + 3;
            this.rotation = Math.random() * Math.PI;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += this.gravity;
            this.life -= this.decay;
            if (this.isText) this.rotation += 0.1;
        }

        draw() {
            ctx.globalAlpha = Math.max(0, this.life);
            if (this.isText) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.font = "60px Arial";
                ctx.fillText(this.text, 0, 0);
                ctx.restore();
            } else {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }
    }

    class FloatingText {
        constructor(x, y, text) {
            this.x = x;
            this.y = y;
            this.text = text;
            this.life = 1.0;
            this.vy = -2;
        }
        update() { this.y += this.vy; this.life -= 0.02; }
        draw() {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = "#fff";
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.font = "bold 40px Arial";
            ctx.strokeText(this.text, this.x, this.y);
            ctx.fillText(this.text, this.x, this.y);
            ctx.globalAlpha = 1.0;
        }
    }

    // --- æ¸¸æˆå¾ªç¯ä¸é€»è¾‘ ---

    function startGame() {
        score = 0;
        lives = 3;
        gameTime = 0;
        fruits = [];
        particles = [];
        trailPoints = [];
        updateUI();
        
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        
        gameState = 'PLAYING';
        spawnLoop();
        requestAnimationFrame(gameLoop);
    }

    function spawnLoop() {
        if (gameState !== 'PLAYING') return;
        const baseInterval = 1500;
        const interval = Math.max(600, baseInterval - (gameTime * 0.2));
        
        fruits.push(new Fruit());
        if (Math.random() < 0.2 && gameTime > 500) fruits.push(new Fruit());

        fruits = fruits.filter(f => f.active);
        setTimeout(spawnLoop, interval);
    }

    function addTrailPoint(x, y) {
        trailPoints.push({ x, y, life: 1.0 });
    }

    function updateTrail() {
        for (let i = trailPoints.length - 1; i >= 0; i--) {
            trailPoints[i].life -= 0.15;
            if (trailPoints[i].life <= 0) trailPoints.splice(i, 1);
        }
    }

    function drawTrail() {
        if (trailPoints.length < 2) return;
        ctx.beginPath();
        ctx.moveTo(trailPoints[0].x, trailPoints[0].y);
        for (let i = 1; i < trailPoints.length; i++) {
            const p = trailPoints[i];
            ctx.strokeStyle = `rgba(255, 255, 255, ${p.life})`;
            ctx.lineWidth = p.life * 15;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#00ffff';
        ctx.stroke();
        ctx.shadowBlur = 0;
    }

    function checkCollisions(x, y) {
        if (trailPoints.length < 2) return; 
        fruits.forEach(fruit => {
            if (fruit.active && !fruit.sliced) {
                const dx = x - fruit.x;
                const dy = y - fruit.y;
                if (dx*dx + dy*dy < fruit.type.radius * fruit.type.radius * 1.5) {
                    sliceFruit(fruit);
                }
            }
        });
    }

    function sliceFruit(fruit) {
        fruit.sliced = true;
        playSound('slice');

        if (fruit.isBomb) {
            createExplosion(fruit.x, fruit.y);
            triggerGameOver();
        } else {
            score += fruit.type.points;
            updateUI();
            for (let i = 0; i < 10; i++) {
                particles.push(new Particle(fruit.x, fruit.y, fruit.type.color));
            }
            particles.push(new FloatingText(fruit.x, fruit.y, `+${fruit.type.points}`));
            
            // æ®‹éª¸
            const p1 = new Particle(fruit.x, fruit.y, null, true, fruit.type.emoji);
            p1.vx = -4; p1.vy = -4;
            const p2 = new Particle(fruit.x, fruit.y, null, true, fruit.type.emoji);
            p2.vx = 4; p2.vy = -4;
            particles.push(p1, p2);
        }
    }

    function createExplosion(x, y) {
        for (let i = 0; i < 30; i++) {
            particles.push(new Particle(x, y, '#ff0000'));
        }
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function loseLife() {
        lives--;
        updateUI();
        if (lives <= 0) triggerGameOver();
    }

    function updateUI() {
        scoreEl.innerText = `åˆ†æ•°: ${score}`;
        let hearts = '';
        for(let i=0; i<lives; i++) hearts += 'â¤ï¸';
        livesEl.innerText = hearts;
    }

    function triggerGameOver() {
        gameState = 'GAMEOVER';
        finalScoreEl.innerText = score;
        if (score > bestScore) {
            bestScore = score;
            try {
                localStorage.setItem('fruitNinjaBestScore', bestScore);
            } catch (e) {}
            bestScoreEl.innerText = `æœ€é«˜: ${bestScore}`;
        }
        gameOverScreen.classList.remove('hidden');
    }

    function gameLoop() {
        if (gameState !== 'PLAYING' && particles.length === 0) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (gameState === 'PLAYING') {
            gameTime++;
            fruits.forEach(f => { f.update(); f.draw(); });
        }

        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            particles[i].draw();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        updateTrail();
        drawTrail();

        if (gameState === 'PLAYING' || particles.length > 0) {
            requestAnimationFrame(gameLoop);
        }
    }
</script>
</body>
</html>